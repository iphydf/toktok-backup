{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847/commits"
        },
        "html": {
            "href": "https://github.com/TokTok/c-toxcore/pull/1847"
        },
        "issue": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
        },
        "statuses": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/statuses/ebbe631c714fe38c851495532fdc3fbb481da7f8"
        }
    },
    "active_lock_reason": null,
    "assignee": {
        "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
        "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
        "followers_url": "https://api.github.com/users/iphydf/followers",
        "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
        "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/iphydf",
        "id": 10647936,
        "login": "iphydf",
        "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
        "organizations_url": "https://api.github.com/users/iphydf/orgs",
        "received_events_url": "https://api.github.com/users/iphydf/received_events",
        "repos_url": "https://api.github.com/users/iphydf/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/iphydf"
    },
    "assignees": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
            "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
            "followers_url": "https://api.github.com/users/iphydf/followers",
            "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
            "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/iphydf",
            "id": 10647936,
            "login": "iphydf",
            "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
            "organizations_url": "https://api.github.com/users/iphydf/orgs",
            "received_events_url": "https://api.github.com/users/iphydf/received_events",
            "repos_url": "https://api.github.com/users/iphydf/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/iphydf"
        }
    ],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "TokTok:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/TokTok/c-toxcore/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/TokTok/c-toxcore/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/TokTok/c-toxcore/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/TokTok/c-toxcore/branches{/branch}",
            "clone_url": "https://github.com/TokTok/c-toxcore.git",
            "collaborators_url": "https://api.github.com/repos/TokTok/c-toxcore/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/comments{/number}",
            "commits_url": "https://api.github.com/repos/TokTok/c-toxcore/commits{/sha}",
            "compare_url": "https://api.github.com/repos/TokTok/c-toxcore/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/TokTok/c-toxcore/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/TokTok/c-toxcore/contributors",
            "created_at": "2016-07-06T08:15:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/TokTok/c-toxcore/deployments",
            "description": "The future of online communications.",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/TokTok/c-toxcore/downloads",
            "events_url": "https://api.github.com/repos/TokTok/c-toxcore/events",
            "fork": true,
            "forks": 283,
            "forks_count": 283,
            "forks_url": "https://api.github.com/repos/TokTok/c-toxcore/forks",
            "full_name": "TokTok/c-toxcore",
            "git_commits_url": "https://api.github.com/repos/TokTok/c-toxcore/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/TokTok/c-toxcore/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/TokTok/c-toxcore/git/tags{/sha}",
            "git_url": "git://github.com/TokTok/c-toxcore.git",
            "has_discussions": false,
            "has_downloads": false,
            "has_issues": true,
            "has_pages": false,
            "has_projects": false,
            "has_wiki": false,
            "homepage": "https://tox.chat",
            "hooks_url": "https://api.github.com/repos/TokTok/c-toxcore/hooks",
            "html_url": "https://github.com/TokTok/c-toxcore",
            "id": 62703642,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/TokTok/c-toxcore/issues{/number}",
            "keys_url": "https://api.github.com/repos/TokTok/c-toxcore/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/labels{/name}",
            "language": "C",
            "languages_url": "https://api.github.com/repos/TokTok/c-toxcore/languages",
            "license": {
                "key": "gpl-3.0",
                "name": "GNU General Public License v3.0",
                "node_id": "MDc6TGljZW5zZTk=",
                "spdx_id": "GPL-3.0",
                "url": "https://api.github.com/licenses/gpl-3.0"
            },
            "merges_url": "https://api.github.com/repos/TokTok/c-toxcore/merges",
            "milestones_url": "https://api.github.com/repos/TokTok/c-toxcore/milestones{/number}",
            "mirror_url": null,
            "name": "c-toxcore",
            "node_id": "MDEwOlJlcG9zaXRvcnk2MjcwMzY0Mg==",
            "notifications_url": "https://api.github.com/repos/TokTok/c-toxcore/notifications{?since,all,participating}",
            "open_issues": 210,
            "open_issues_count": 210,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17427091?v=4",
                "events_url": "https://api.github.com/users/TokTok/events{/privacy}",
                "followers_url": "https://api.github.com/users/TokTok/followers",
                "following_url": "https://api.github.com/users/TokTok/following{/other_user}",
                "gists_url": "https://api.github.com/users/TokTok/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/TokTok",
                "id": 17427091,
                "login": "TokTok",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjE3NDI3MDkx",
                "organizations_url": "https://api.github.com/users/TokTok/orgs",
                "received_events_url": "https://api.github.com/users/TokTok/received_events",
                "repos_url": "https://api.github.com/users/TokTok/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/TokTok/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/TokTok/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/TokTok"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls{/number}",
            "pushed_at": "2024-02-23T16:21:31Z",
            "releases_url": "https://api.github.com/repos/TokTok/c-toxcore/releases{/id}",
            "size": 37461,
            "ssh_url": "git@github.com:TokTok/c-toxcore.git",
            "stargazers_count": 2116,
            "stargazers_url": "https://api.github.com/repos/TokTok/c-toxcore/stargazers",
            "statuses_url": "https://api.github.com/repos/TokTok/c-toxcore/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/TokTok/c-toxcore/subscribers",
            "subscription_url": "https://api.github.com/repos/TokTok/c-toxcore/subscription",
            "svn_url": "https://github.com/TokTok/c-toxcore",
            "tags_url": "https://api.github.com/repos/TokTok/c-toxcore/tags",
            "teams_url": "https://api.github.com/repos/TokTok/c-toxcore/teams",
            "topics": [
                "cryptography",
                "encryption",
                "network",
                "p2p",
                "security",
                "toxcore"
            ],
            "trees_url": "https://api.github.com/repos/TokTok/c-toxcore/git/trees{/sha}",
            "updated_at": "2024-02-23T18:58:26Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore",
            "visibility": "public",
            "watchers": 2116,
            "watchers_count": 2116,
            "web_commit_signoff_required": false
        },
        "sha": "87bcc4322d50d2ae7714e734b6468ef43dd818a7",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/17427091?v=4",
            "events_url": "https://api.github.com/users/TokTok/events{/privacy}",
            "followers_url": "https://api.github.com/users/TokTok/followers",
            "following_url": "https://api.github.com/users/TokTok/following{/other_user}",
            "gists_url": "https://api.github.com/users/TokTok/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/TokTok",
            "id": 17427091,
            "login": "TokTok",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjE3NDI3MDkx",
            "organizations_url": "https://api.github.com/users/TokTok/orgs",
            "received_events_url": "https://api.github.com/users/TokTok/received_events",
            "repos_url": "https://api.github.com/users/TokTok/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/TokTok/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TokTok/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/TokTok"
        }
    },
    "body": "This tests tox_iterate in a separate thread, and the two ToxAV modes.\n\n<!-- Reviewable:start -->\n---\nThis change is [<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/toktok/c-toxcore/1847)\n<!-- Reviewable:end -->\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r778397847"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778397847"
                }
            },
            "author_association": "MEMBER",
            "body": "Unfortunately, this is C++, and cimple doesn't understand C++, so here comes the manual diagnostic:\r\n\r\n```\r\ntoxav_mt_test.cc:408: variable `i' can be reduced in scope\r\ntoxav_mt_test.cc:410:   possibly to here\r\n```",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-04T21:24:06Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;\n+  std::atomic_uint32_t call_state;\n+\n+  std::atomic<TimePoint> call_start;\n+  std::atomic_bool in_call;\n+\n+  std::atomic_bool video_received;\n+  std::atomic_bool audio_received;\n+  std::string name_;\n+};\n+\n+struct DUMMY_PCM {\n+  static constexpr size_t sample_count = 960;\n+  static constexpr int16_t pcm[sample_count] = {0};\n+  static constexpr uint8_t channels = 1;\n+  static constexpr uint32_t sampling_rate = 48000;\n+};\n+\n+struct DUMMY_VIDEO {\n+  // https://en.wikipedia.org/wiki/Graphics_display_resolution#QQVGA size\n+  static constexpr uint16_t width = 160;\n+  static constexpr uint16_t height = 120;\n+\n+  static constexpr uint8_t y[width * height] = {0};\n+  static constexpr uint8_t u[width / 2 * height / 2] = {0};\n+  static constexpr uint8_t v[width / 2 * height / 2] = {0};\n+};\n+\n+// FIXME: once we upgrade to C++17, remove these, reason: https://stackoverflow.com/a/28846608\n+constexpr std::chrono::duration<double> AV_State::AUTO_HANGUP_TIME;\n+constexpr int16_t DUMMY_PCM::pcm[];\n+constexpr uint8_t DUMMY_VIDEO::y[];\n+constexpr uint8_t DUMMY_VIDEO::u[];\n+constexpr uint8_t DUMMY_VIDEO::v[];\n+\n+}  // namespace\n+\n+static void test_av(bool combined) {\n+  std::cout << \"Testing Audio and Video in\" << (combined ? \"combined\" : \"separate\") << \" threads\"\n+            << std::endl;\n+  auto toxes = prepareNetwork(2);\n+\n+  AV_State alice(std::move(toxes[0]), \"alice\", false);\n+  AV_State bob(std::move(toxes[1]), \"bob\", false);\n+\n+  // Let alice call bob\n+  {\n+    std::lock_guard<std::mutex>(alice.getToxLoopLock());\n+    Toxav_Err_Call err;\n+    ck_assert(\n+        toxav_call(alice.getToxAV(), 0, AV_State::TEST_A_BITRATE, AV_State::TEST_V_BITRATE, &err));\n+    ck_assert(err == TOXAV_ERR_CALL_OK);\n+  }\n+\n+  std::cout << \"alice started a call\" << std::endl;\n+\n+  auto poll_state = [](AV_State &av, uint32_t expected, uint32_t max_tries,\n+                       uint32_t delay_ms) -> bool {\n+    uint32_t i;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r778397847",
            "id": 778397847,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uZWiX",
            "original_commit_id": "6ea17e8688f4d9e96bdf4828653352fbf2fa143b",
            "original_line": 408,
            "original_position": 408,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844018401,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778397847/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-04T21:24:41Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778397847",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r778401450"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778401450"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd move this down to just before the for-loop, and move the initialisation into the for-init-stmt.",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-04T21:30:50Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r778401450",
            "id": 778401450,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uZXaq",
            "original_commit_id": "6ea17e8688f4d9e96bdf4828653352fbf2fa143b",
            "original_line": 84,
            "original_position": 84,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844023442,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778401450/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-04T21:31:07Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/778401450",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779059842"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779059842"
                }
            },
            "author_association": "MEMBER",
            "body": "\"bootstrap\"",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T18:50:53Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779059842",
            "id": 779059842,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub4KC",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 49,
            "original_position": 49,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779059842/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779059842",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779060833"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779060833"
                }
            },
            "author_association": "MEMBER",
            "body": "\"incoming\"",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T18:52:33Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779060833",
            "id": 779060833,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub4Zh",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 350,
            "original_position": 350,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779060833/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779060833",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779061186"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061186"
                }
            },
            "author_association": "MEMBER",
            "body": "What's the convention that makes `name` into `name_` but leaves `audio_received` without trailing `_`?",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T18:53:07Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;\n+  std::atomic_uint32_t call_state;\n+\n+  std::atomic<TimePoint> call_start;\n+  std::atomic_bool in_call;\n+\n+  std::atomic_bool video_received;\n+  std::atomic_bool audio_received;\n+  std::string name_;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779061186",
            "id": 779061186,
            "line": 371,
            "node_id": "PRRC_kwDOA7zIGs4ub4fC",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 371,
            "original_position": 358,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": 371,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061186/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061186",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779061646"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061646"
                }
            },
            "author_association": "MEMBER",
            "body": "Why is this outside the `namespace{}`?",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T18:53:54Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;\n+  std::atomic_uint32_t call_state;\n+\n+  std::atomic<TimePoint> call_start;\n+  std::atomic_bool in_call;\n+\n+  std::atomic_bool video_received;\n+  std::atomic_bool audio_received;\n+  std::string name_;\n+};\n+\n+struct DUMMY_PCM {\n+  static constexpr size_t sample_count = 960;\n+  static constexpr int16_t pcm[sample_count] = {0};\n+  static constexpr uint8_t channels = 1;\n+  static constexpr uint32_t sampling_rate = 48000;\n+};\n+\n+struct DUMMY_VIDEO {\n+  // https://en.wikipedia.org/wiki/Graphics_display_resolution#QQVGA size\n+  static constexpr uint16_t width = 160;\n+  static constexpr uint16_t height = 120;\n+\n+  static constexpr uint8_t y[width * height] = {0};\n+  static constexpr uint8_t u[width / 2 * height / 2] = {0};\n+  static constexpr uint8_t v[width / 2 * height / 2] = {0};\n+};\n+\n+// FIXME: once we upgrade to C++17, remove these, reason: https://stackoverflow.com/a/28846608\n+constexpr std::chrono::duration<double> AV_State::AUTO_HANGUP_TIME;\n+constexpr int16_t DUMMY_PCM::pcm[];\n+constexpr uint8_t DUMMY_VIDEO::y[];\n+constexpr uint8_t DUMMY_VIDEO::u[];\n+constexpr uint8_t DUMMY_VIDEO::v[];\n+\n+}  // namespace\n+\n+static void test_av(bool combined) {",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779061646",
            "id": 779061646,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub4mO",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 387,
            "original_position": 387,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061646/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779061646",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779064370"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779064370"
                }
            },
            "author_association": "MEMBER",
            "body": "`combined_av` is a little clearer on what is being combined here.",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T18:58:18Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779064370",
            "id": 779064370,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub5Qy",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 346,
            "original_position": 346,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779064370/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779064370",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779067598"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779067598"
                }
            },
            "author_association": "MEMBER",
            "body": "The naming convention in this file is a bit all over the place. E.g. `TimePoint` and `Tox_Ptr`. Also, some top level functions are `snake_case`, others are `dromedaryCase`. Since you're not using the Tox naming conventions (which are somewhat self-described by all the other sources), can you briefly describe them at the top of the file? Just a list of \"kind of identifier: naming convention\".",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T19:03:35Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779067598",
            "id": 779067598,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub6DO",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 19,
            "original_position": 19,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779067598/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779067598",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779068051"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068051"
                }
            },
            "author_association": "MEMBER",
            "body": "Do we expect other friend requests to arrive? Maybe we should assert that we don't.",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T19:04:24Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779068051",
            "id": 779068051,
            "line": 40,
            "node_id": "PRRC_kwDOA7zIGs4ub6KT",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 40,
            "original_position": 40,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": 40,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068051/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068051",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779068327"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068327"
                }
            },
            "author_association": "MEMBER",
            "body": "`uint32_t(-1)` or `static_cast` (I think I'd prefer the former, but the latter might be slightly clearer).",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-05T19:04:53Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r779068327",
            "id": 779068327,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ub6On",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 844951545,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068327/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-05T19:06:23Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/779068327",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660253"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660253"
                }
            },
            "author_association": "MEMBER",
            "body": "Should be fixed now",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:33:24Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660253",
            "id": 780660253,
            "in_reply_to_id": 779068051,
            "line": 40,
            "node_id": "PRRC_kwDOA7zIGs4uh-4d",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 40,
            "original_position": 40,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": 40,
            "pull_request_review_id": 847147629,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660253/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:33:24Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660253",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660282"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660282"
                }
            },
            "author_association": "MEMBER",
            "body": "unified it, all members now are `snek_` case",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:34:05Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;\n+  std::atomic_uint32_t call_state;\n+\n+  std::atomic<TimePoint> call_start;\n+  std::atomic_bool in_call;\n+\n+  std::atomic_bool video_received;\n+  std::atomic_bool audio_received;\n+  std::string name_;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660282",
            "id": 780660282,
            "in_reply_to_id": 779061186,
            "line": 371,
            "node_id": "PRRC_kwDOA7zIGs4uh-46",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 371,
            "original_position": 358,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": 371,
            "pull_request_review_id": 847147670,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660282/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:34:05Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660282",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660358"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660358"
                }
            },
            "author_association": "MEMBER",
            "body": "Done",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:34:56Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660358",
            "id": 780660358,
            "in_reply_to_id": 778401450,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uh-6G",
            "original_commit_id": "6ea17e8688f4d9e96bdf4828653352fbf2fa143b",
            "original_line": 84,
            "original_position": 84,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 847147728,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660358/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:34:57Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660358",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660458"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660458"
                }
            },
            "author_association": "MEMBER",
            "body": "Moved inside",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:35:45Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;\n+  ToxAV_Ptr toxAV_;\n+\n+  std::atomic_bool stop_threads;\n+  std::atomic_bool incomming;\n+  std::atomic_uint32_t call_state;\n+\n+  std::atomic<TimePoint> call_start;\n+  std::atomic_bool in_call;\n+\n+  std::atomic_bool video_received;\n+  std::atomic_bool audio_received;\n+  std::string name_;\n+};\n+\n+struct DUMMY_PCM {\n+  static constexpr size_t sample_count = 960;\n+  static constexpr int16_t pcm[sample_count] = {0};\n+  static constexpr uint8_t channels = 1;\n+  static constexpr uint32_t sampling_rate = 48000;\n+};\n+\n+struct DUMMY_VIDEO {\n+  // https://en.wikipedia.org/wiki/Graphics_display_resolution#QQVGA size\n+  static constexpr uint16_t width = 160;\n+  static constexpr uint16_t height = 120;\n+\n+  static constexpr uint8_t y[width * height] = {0};\n+  static constexpr uint8_t u[width / 2 * height / 2] = {0};\n+  static constexpr uint8_t v[width / 2 * height / 2] = {0};\n+};\n+\n+// FIXME: once we upgrade to C++17, remove these, reason: https://stackoverflow.com/a/28846608\n+constexpr std::chrono::duration<double> AV_State::AUTO_HANGUP_TIME;\n+constexpr int16_t DUMMY_PCM::pcm[];\n+constexpr uint8_t DUMMY_VIDEO::y[];\n+constexpr uint8_t DUMMY_VIDEO::u[];\n+constexpr uint8_t DUMMY_VIDEO::v[];\n+\n+}  // namespace\n+\n+static void test_av(bool combined) {",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660458",
            "id": 780660458,
            "in_reply_to_id": 779061646,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uh-7q",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 387,
            "original_position": 387,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 847147786,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660458/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:35:45Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660458",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660462"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660462"
                }
            },
            "author_association": "MEMBER",
            "body": "Done",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:35:51Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);\n+  }\n+}\n+\n+std::vector<Tox_Ptr> prepareNetwork(uint32_t count) {\n+  Tox_Err_New error;\n+\n+  // Temporary bootstrap node\n+  std::printf(\"Created 1 instance of Tox as boostrap node\\n\");\n+  Tox_Ptr bootstrap = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+  ck_assert(error == TOX_ERR_NEW_OK);\n+\n+  uint8_t bootstrap_key[TOX_PUBLIC_KEY_SIZE];\n+  tox_self_get_dht_id(bootstrap.get(), bootstrap_key);\n+  const uint16_t bootstrap_port = tox_self_get_udp_port(bootstrap.get(), nullptr);\n+\n+  std::cout << \"Bootstrapping \" << std::to_string(count) << \" Tox nodes\" << std::endl;\n+\n+  std::vector<Tox_Ptr> toxes(count);\n+\n+  for (auto &tox : toxes) {\n+    tox = Tox_Ptr(tox_new_log(nullptr, &error, nullptr));\n+    ck_assert(error == TOX_ERR_NEW_OK);\n+\n+    tox_bootstrap(tox.get(), \"localhost\", bootstrap_port, bootstrap_key, nullptr);\n+    tox_callback_friend_request(tox.get(), t_accept_friend_request_cb);\n+  }\n+\n+  // Create fully meshed friend network\n+  for (size_t i = 0; i < toxes.size(); ++i) {\n+    uint8_t address[TOX_ADDRESS_SIZE];\n+    tox_self_get_address(toxes[i].get(), address);\n+\n+    for (size_t j = i + 1; j < toxes.size(); ++j) {\n+      Tox_Err_Friend_Add error_add;\n+      tox_friend_add(toxes[j].get(), address, (const uint8_t *)\"gentoo\", 7, &error_add);\n+      ck_assert(error_add == TOX_ERR_FRIEND_ADD_OK);\n+    }\n+  }\n+\n+  // temporarily add bootstrap node to end of toxes, so we can iterate all\n+  toxes.push_back(std::move(bootstrap));\n+\n+  uint32_t bootstrap_iteration = 0;\n+  bool online = false;\n+\n+  auto bootstrap_start_time = Clock::now();\n+\n+  for (; bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS; ++bootstrap_iteration) {\n+    for (auto &tox : toxes) {\n+      tox_iterate(tox.get(), nullptr);\n+    }\n+\n+    if (!online) {\n+      size_t online_cnt = std::count_if(toxes.cbegin(), toxes.cend(), [](const Tox_Ptr &tox) {\n+        return tox_self_get_connection_status(tox.get());\n+      });\n+\n+      if (online_cnt == toxes.size()) {\n+        std::chrono::duration<double> bootstrap_time = Clock::now() - bootstrap_start_time;\n+        std::cout << \"Toxes are online, took \" << bootstrap_time.count() << \"s\" << std::endl;\n+        online = true;\n+      }\n+    }\n+\n+    bool friends_connected = true;\n+\n+    // Check if the friends are connected to each other, bootstrap node will have empty friends list\n+    for (auto &tox : toxes) {\n+      std::vector<uint32_t> friend_list;\n+      friend_list.resize(tox_self_get_friend_list_size(tox.get()));\n+      tox_self_get_friend_list(tox.get(), friend_list.data());\n+\n+      for (auto friend_id : friend_list) {\n+        friends_connected &=\n+            tox_friend_get_connection_status(tox.get(), friend_id, nullptr) == TOX_CONNECTION_UDP;\n+      }\n+    }\n+\n+    if (friends_connected) {\n+      break;\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(20));\n+  }\n+\n+  ck_assert(bootstrap_iteration < MAX_BOOTSTRAP_ITERATIONS);\n+  std::chrono::duration<double> mesh_time = Clock::now() - bootstrap_start_time;\n+  std::cout << \"Iterations to connect friend mesh: \" << std::to_string(bootstrap_iteration)\n+            << std::endl;\n+  std::cout << \"Time to connect friend mesh: \" << mesh_time.count() << \"s\" << std::endl;\n+\n+  // Remove bootstrap node\n+  toxes.pop_back();\n+\n+  return toxes;\n+}\n+\n+class AV_State {\n+ public:\n+  explicit AV_State(Tox_Ptr tox, std::string name, bool combined = false)\n+      : tox_(std::move(tox)),\n+        combined_(combined),\n+        stop_threads{false},\n+        incomming{false},\n+        call_state{0},\n+        video_received{false},\n+        audio_received{false},\n+        name_{name} {\n+    Toxav_Err_New error;\n+    toxAV_ = ToxAV_Ptr(toxav_new(tox_.get(), &error));\n+    ck_assert(error == TOXAV_ERR_NEW_OK);\n+\n+    toxav_callback_call(toxAV_.get(), &AV_State::toxav_call_cb, this);\n+    toxav_callback_call_state(toxAV_.get(), &AV_State::toxav_call_state_cb, this);\n+    toxav_callback_video_receive_frame(toxAV_.get(), &AV_State::toxav_receive_video_frame_cb, this);\n+    toxav_callback_audio_receive_frame(toxAV_.get(), &AV_State::toxav_receive_audio_frame_cb, this);\n+\n+    tox_thread = std::thread(&AV_State::tox_iterator, this);\n+\n+    if (combined) {\n+      av_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_BOTH);\n+    } else {\n+      audio_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_AUDIO);\n+      video_thread = std::thread(&AV_State::toxav_iterator, this, Iteration_Type::TOXAV_VIDEO);\n+    }\n+  }\n+\n+  ~AV_State() { stopThreads(); }\n+\n+  ToxAV *getToxAV() const { return toxAV_.get(); }\n+  std::mutex &getToxLoopLock() { return tox_loop_lock; }\n+  bool inCall() const { return in_call.load(); }\n+  uint32_t getCallState() const { return call_state.load(); }\n+  void stopThreads() {\n+    if (stop_threads.exchange(true)) {\n+      // already stopped\n+      return;\n+    }\n+\n+    tox_thread.join();\n+\n+    if (combined_) {\n+      av_thread.join();\n+    } else {\n+      audio_thread.join();\n+      video_thread.join();\n+    }\n+  }\n+\n+  bool didReceiveAudio() const { return audio_received.load(); }\n+  bool didReceiveVideo() const { return video_received.load(); }\n+\n+  static constexpr uint32_t TEST_A_BITRATE = 48;    // In kbit/s\n+  static constexpr uint32_t TEST_V_BITRATE = 4000;  // In kbit/s\n+  static constexpr std::chrono::duration<double> AUTO_HANGUP_TIME = std::chrono::seconds(2);\n+\n+ private:\n+  enum class Iteration_Type {\n+    TOXAV_AUDIO,\n+    TOXAV_VIDEO,\n+    TOXAV_BOTH,\n+  };\n+\n+  static void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled,\n+                            bool video_enabled, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Handling CALL callback\" << std::endl;\n+    me->incomming.store(true);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+  }\n+\n+  static void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state,\n+                                  void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    ck_assert(std::this_thread::get_id() == me->tox_thread.get_id());\n+    ck_assert(state != TOXAV_FRIEND_CALL_STATE_ERROR);\n+    std::cout << \"[\" << me->name_ << \"] State changed to: \" << std::to_string(state) << std::endl;\n+    me->call_state.store(state);\n+    TimePoint tp = me->call_start.load();\n+\n+    if (state != TOXAV_FRIEND_CALL_STATE_NONE && tp == TimePoint()) {\n+      me->call_start.store(Clock::now());\n+      me->in_call.store(true);\n+    }\n+  }\n+\n+  static void toxav_receive_video_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width,\n+                                           uint16_t height, uint8_t const *y, uint8_t const *u,\n+                                           uint8_t const *v, int32_t ystride, int32_t ustride,\n+                                           int32_t vstride, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received video payload\" << std::endl;\n+\n+    // toxav.h states that receive events are emitted from their respective threads\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->video_thread.get_id());\n+    }\n+\n+    me->video_received = true;\n+  }\n+\n+  static void toxav_receive_audio_frame_cb(ToxAV *av, uint32_t friend_number, int16_t const *pcm,\n+                                           size_t sample_count, uint8_t channels,\n+                                           uint32_t sampling_rate, void *user_data) {\n+    AV_State *me = static_cast<AV_State *>(user_data);\n+    std::cout << \"[\" << me->name_ << \"] Received audio payload\" << std::endl;\n+\n+    if (me->combined_) {\n+      ck_assert(std::this_thread::get_id() == me->av_thread.get_id());\n+    } else {\n+      ck_assert(std::this_thread::get_id() == me->audio_thread.get_id());\n+    }\n+\n+    me->audio_received = true;\n+  }\n+\n+  void tox_iterator() {\n+    while (!stop_threads.load()) {\n+      // Perform this block only while loop lock is held\n+      {\n+        std::lock_guard<std::mutex> lock(tox_loop_lock);\n+        tox_iterate(tox_.get(), this);\n+\n+        // handle incoming call\n+        if (incomming.exchange(false)) {\n+          Toxav_Err_Answer answer_err;\n+          toxav_answer(toxAV_.get(), 0, TEST_A_BITRATE, TEST_V_BITRATE, &answer_err);\n+\n+          if (answer_err != TOXAV_ERR_ANSWER_OK) {\n+            std::printf(\"toxav_answer failed, Toxav_Err_Answer: %d\\n\", answer_err);\n+            ck_assert(0);\n+          }\n+\n+          std::cout << \"[\" << name_ << \"] Answering call\" << std::endl;\n+\n+          call_start = Clock::now();\n+          in_call.store(true);\n+        }\n+\n+        if (in_call.load()) {\n+          uint32_t state = call_state.load();\n+          TimePoint tp = call_start.load();\n+          std::chrono::duration<double> call_time = Clock::now() - tp;\n+\n+          if (state == TOXAV_FRIEND_CALL_STATE_FINISHED) {\n+            std::cout << \"[\" << name_ << \"] Call ended by other side after: \" << call_time.count()\n+                      << \"s\" << std::endl;\n+            in_call.store(false);\n+          } else if (tp > TimePoint() && call_time > AV_State::AUTO_HANGUP_TIME) {\n+            std::cout << \"[\" << name_ << \"] Ending call after: \" << call_time.count() << \"s\"\n+                      << std::endl;\n+            Toxav_Err_Call_Control cc_err;\n+            toxav_call_control(toxAV_.get(), 0, TOXAV_CALL_CONTROL_CANCEL, &cc_err);\n+\n+            // Ignore FRIEND_NOT_IN_CALL for the case where the other side hangs up simultaneously\n+            if (cc_err != TOXAV_ERR_CALL_CONTROL_OK &&\n+                cc_err != TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL) {\n+              std::printf(\"toxav_call_control failed: %d\\n\", cc_err);\n+              ck_assert(0);\n+            }\n+\n+            in_call.store(false);\n+          }\n+        }\n+      }\n+\n+      std::this_thread::sleep_for(std::chrono::milliseconds(tox_iteration_interval(tox_.get())));\n+    }\n+  }\n+\n+  void toxav_iterator(Iteration_Type type) {\n+    while (!stop_threads.load()) {\n+      switch (type) {\n+        case Iteration_Type::TOXAV_AUDIO:\n+          toxav_audio_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_audio_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_VIDEO:\n+          toxav_video_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_video_iteration_interval(toxAV_.get())));\n+          break;\n+\n+        case Iteration_Type::TOXAV_BOTH:\n+          toxav_iterate(toxAV_.get());\n+          std::this_thread::sleep_for(\n+              std::chrono::milliseconds(toxav_iteration_interval(toxAV_.get())));\n+          break;\n+      }\n+    }\n+  }\n+\n+  std::thread tox_thread;\n+  std::thread audio_thread;\n+  std::thread video_thread;\n+  std::thread av_thread;\n+\n+  std::mutex tox_loop_lock;\n+\n+  Tox_Ptr tox_;\n+  bool combined_;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660462",
            "id": 780660462,
            "in_reply_to_id": 779064370,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uh-7u",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 346,
            "original_position": 346,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 847147792,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660462/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:35:51Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660462",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660484"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660484"
                }
            },
            "author_association": "MEMBER",
            "body": "Should be mirroring random_testing.cc now",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:36:18Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660484",
            "id": 780660484,
            "in_reply_to_id": 779067598,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uh-8E",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 19,
            "original_position": 19,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 847147818,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660484/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:36:18Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660484",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660535"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660535"
                }
            },
            "author_association": "MEMBER",
            "body": "Fixed and opened https://github.com/TokTok/c-toxcore/issues/1855 because I copied this.",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-08T11:36:50Z",
            "diff_hunk": "@@ -0,0 +1,498 @@\n+#include <algorithm>\n+#include <atomic>\n+#include <chrono>\n+#include <cstdio>\n+#include <cstring>\n+#include <iostream>\n+#include <memory>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+#include \"../testing/misc_tools.h\"\n+#include \"../toxav/toxav.h\"\n+#include \"../toxcore/tox.h\"\n+#include \"check_compat.h\"\n+\n+// Make lines shorter\n+using Clock = std::chrono::high_resolution_clock;\n+using TimePoint = std::chrono::time_point<Clock>;\n+\n+namespace {\n+// Maximum amount of time in iterations to wait for bootstrapping and friend\n+// connections to succeed.\n+constexpr uint32_t MAX_BOOTSTRAP_ITERATIONS = 1000;\n+\n+struct Tox_Deleter {\n+  void operator()(Tox *tox) const { tox_kill(tox); }\n+};\n+\n+using Tox_Ptr = std::unique_ptr<Tox, Tox_Deleter>;\n+\n+struct ToxAV_Deleter {\n+  void operator()(ToxAV *tox) const { toxav_kill(tox); }\n+};\n+\n+using ToxAV_Ptr = std::unique_ptr<ToxAV, ToxAV_Deleter>;\n+\n+static void t_accept_friend_request_cb(Tox *m, const uint8_t *public_key, const uint8_t *data,\n+                                       size_t length, void *userdata) {\n+  if (length == 7 && std::memcmp(\"gentoo\", data, 7) == 0) {\n+    ck_assert(tox_friend_add_norequest(m, public_key, nullptr) != (uint32_t)-1);",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780660535",
            "id": 780660535,
            "in_reply_to_id": 779068327,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4uh-83",
            "original_commit_id": "77fb9040b27f474e4fa5dfd5563990dbfec732ab",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "auto_tests/toxav_mt_test.cc",
            "position": null,
            "pull_request_review_id": 847147873,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660535/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-08T11:36:50Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780660535",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780719971"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780719971"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe we can pass the suffix and avoid duplicating this? It's literally 1 byte difference between the two macros.",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-09T00:18:45Z",
            "diff_hunk": "@@ -406,6 +406,19 @@ function(auto_test target)\n   endif()\n endfunction()\n \n+function(auto_test_cc target)",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780719971",
            "id": 780719971,
            "line": 413,
            "node_id": "PRRC_kwDOA7zIGs4uiNdj",
            "original_commit_id": "4cf603c9e2208d8a9cb148107a804e9ee1439bde",
            "original_line": 413,
            "original_position": 4,
            "original_start_line": null,
            "path": "CMakeLists.txt",
            "position": 21,
            "pull_request_review_id": 847204230,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780719971/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-09T00:18:45Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780719971",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780770488"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780770488"
                }
            },
            "author_association": "MEMBER",
            "body": "Does this work for you?",
            "commit_id": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "created_at": "2022-01-09T11:43:02Z",
            "diff_hunk": "@@ -406,6 +406,19 @@ function(auto_test target)\n   endif()\n endfunction()\n \n+function(auto_test_cc target)",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#discussion_r780770488",
            "id": 780770488,
            "in_reply_to_id": 780719971,
            "line": 413,
            "node_id": "PRRC_kwDOA7zIGs4uiZy4",
            "original_commit_id": "4cf603c9e2208d8a9cb148107a804e9ee1439bde",
            "original_line": 413,
            "original_position": 4,
            "original_start_line": null,
            "path": "CMakeLists.txt",
            "position": 21,
            "pull_request_review_id": 847247381,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780770488/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-01-09T11:43:02Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/780770488",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "NONE",
            "body": "[![CLA assistant check](https://cla-assistant.io/pull/badge/signed)](https://cla-assistant.io/TokTok/c-toxcore?pullRequest=1847) <br/>All committers have signed the CLA.",
            "created_at": "2022-01-05T09:58:09Z",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#issuecomment-1005539716",
            "id": 1005539716,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847",
            "node_id": "IC_kwDOA7zIGs4771GE",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1005539716/reactions"
            },
            "updated_at": "2022-01-10T11:29:32Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1005539716",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/11571300?v=4",
                "events_url": "https://api.github.com/users/CLAassistant/events{/privacy}",
                "followers_url": "https://api.github.com/users/CLAassistant/followers",
                "following_url": "https://api.github.com/users/CLAassistant/following{/other_user}",
                "gists_url": "https://api.github.com/users/CLAassistant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/CLAassistant",
                "id": 11571300,
                "login": "CLAassistant",
                "node_id": "MDQ6VXNlcjExNTcxMzAw",
                "organizations_url": "https://api.github.com/users/CLAassistant/orgs",
                "received_events_url": "https://api.github.com/users/CLAassistant/received_events",
                "repos_url": "https://api.github.com/users/CLAassistant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/CLAassistant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/CLAassistant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/CLAassistant"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Huh, me pushing a commit broke Github Actions on this PR. @sudden6 try removing my commit from the PR and then adding it back and pushing it from your account, maybe that will fix it. Keep the commit as it is, such that it's a1247a7 hash, just push it from your account instead. For the context, GitHub has disabled Actions on my account for some reason.",
            "created_at": "2022-01-05T10:44:02Z",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/1847#issuecomment-1005574831",
            "id": 1005574831,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847",
            "node_id": "IC_kwDOA7zIGs4779qv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1005574831/reactions"
            },
            "updated_at": "2022-01-05T10:49:06Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1005574831",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1855294?v=4",
                "events_url": "https://api.github.com/users/nurupo/events{/privacy}",
                "followers_url": "https://api.github.com/users/nurupo/followers",
                "following_url": "https://api.github.com/users/nurupo/following{/other_user}",
                "gists_url": "https://api.github.com/users/nurupo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/nurupo",
                "id": 1855294,
                "login": "nurupo",
                "node_id": "MDQ6VXNlcjE4NTUyOTQ=",
                "organizations_url": "https://api.github.com/users/nurupo/orgs",
                "received_events_url": "https://api.github.com/users/nurupo/received_events",
                "repos_url": "https://api.github.com/users/nurupo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/nurupo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/nurupo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/nurupo"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847/comments",
    "commit_data": [
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            },
            "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/commits/ebbe631c714fe38c851495532fdc3fbb481da7f8/comments",
            "commit": {
                "author": {
                    "date": "2022-01-04T20:05:24Z",
                    "email": "sudden6@gmx.at",
                    "name": "sudden6"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2022-01-14T12:46:50Z",
                    "email": "iphydf@users.noreply.github.com",
                    "name": "iphydf"
                },
                "message": "test: add test for multithreaded ToxAV\n\nThis tests tox_iterate in a separate thread, and the two ToxAV modes.",
                "tree": {
                    "sha": "b3919f24e29fd2040436bac229af0484000dde70",
                    "url": "https://api.github.com/repos/TokTok/c-toxcore/git/trees/b3919f24e29fd2040436bac229af0484000dde70"
                },
                "url": "https://api.github.com/repos/TokTok/c-toxcore/git/commits/ebbe631c714fe38c851495532fdc3fbb481da7f8",
                "verification": {
                    "payload": "tree b3919f24e29fd2040436bac229af0484000dde70\nparent d23222c92fddef2c7a5effdc73917bf5e343ccc1\nauthor sudden6 <sudden6@gmx.at> 1641326724 +0100\ncommitter iphydf <iphydf@users.noreply.github.com> 1642164410 +0000\n\ntest: add test for multithreaded ToxAV\n\nThis tests tox_iterate in a separate thread, and the two ToxAV modes.\n",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEqQ4tlxH906HdaIgsOFXbotdEA8kFAmHhcLoACgkQOFXbotdE\nA8nzYwf/bljy1n+joLBbjbvGG6iL/kQ4QiQKGCEJeb29x3cspWKUxBwXm5gQahW1\ntlMnGQHA+vfq6Vb75Spahn2DufaRRNwPNFKOLcGGDFrO8oTp6DGMgIJ68rqpKeen\nlrFXTV0teZDOhIDH1UBa2Rlt4GXcGCdR9hefWVNhWKPX91WF73L1iEJA7wB+XXwO\nDHLL6aHEKHCvWn+lXFuadhzDM+N9L+tcDfpj6PxTtAld61uHfsGQkuAZ0khtgsu8\nDwiuBkuk+1I67KXnAb5Kyij+y9FZOsVMmkg9vlbEqjKWDSwTHLqC76MX2ZSsV6B2\nxDIm1dFx7gfP2VznLUXHadwPMsySqA==\n=V8kk\n-----END PGP SIGNATURE-----",
                    "verified": true
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            },
            "html_url": "https://github.com/TokTok/c-toxcore/commit/ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "node_id": "C_kwDOBC2LodoAKGViYmU2MzFjNzE0ZmUzOGM4NTE0OTU1MzJmZGMzZmJiNDgxZGE3Zjg",
            "parents": [
                {
                    "html_url": "https://github.com/TokTok/c-toxcore/commit/d23222c92fddef2c7a5effdc73917bf5e343ccc1",
                    "sha": "d23222c92fddef2c7a5effdc73917bf5e343ccc1",
                    "url": "https://api.github.com/repos/TokTok/c-toxcore/commits/d23222c92fddef2c7a5effdc73917bf5e343ccc1"
                }
            ],
            "sha": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/commits/ebbe631c714fe38c851495532fdc3fbb481da7f8"
        }
    ],
    "commits_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847/commits",
    "created_at": "2022-01-04T20:09:33Z",
    "diff_url": "https://github.com/TokTok/c-toxcore/pull/1847.diff",
    "draft": false,
    "head": {
        "label": "sudden6:test/split_iterate",
        "ref": "test/split_iterate",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/sudden6/c-toxcore/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/sudden6/c-toxcore/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/sudden6/c-toxcore/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/sudden6/c-toxcore/branches{/branch}",
            "clone_url": "https://github.com/sudden6/c-toxcore.git",
            "collaborators_url": "https://api.github.com/repos/sudden6/c-toxcore/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/sudden6/c-toxcore/comments{/number}",
            "commits_url": "https://api.github.com/repos/sudden6/c-toxcore/commits{/sha}",
            "compare_url": "https://api.github.com/repos/sudden6/c-toxcore/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/sudden6/c-toxcore/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/sudden6/c-toxcore/contributors",
            "created_at": "2016-10-05T19:48:51Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/sudden6/c-toxcore/deployments",
            "description": "The future of online communications.",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/sudden6/c-toxcore/downloads",
            "events_url": "https://api.github.com/repos/sudden6/c-toxcore/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/sudden6/c-toxcore/forks",
            "full_name": "sudden6/c-toxcore",
            "git_commits_url": "https://api.github.com/repos/sudden6/c-toxcore/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/sudden6/c-toxcore/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/sudden6/c-toxcore/git/tags{/sha}",
            "git_url": "git://github.com/sudden6/c-toxcore.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": false,
            "homepage": "https://tox.chat/",
            "hooks_url": "https://api.github.com/repos/sudden6/c-toxcore/hooks",
            "html_url": "https://github.com/sudden6/c-toxcore",
            "id": 70093729,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/sudden6/c-toxcore/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/sudden6/c-toxcore/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/sudden6/c-toxcore/issues{/number}",
            "keys_url": "https://api.github.com/repos/sudden6/c-toxcore/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/sudden6/c-toxcore/labels{/name}",
            "language": "C",
            "languages_url": "https://api.github.com/repos/sudden6/c-toxcore/languages",
            "license": {
                "key": "gpl-3.0",
                "name": "GNU General Public License v3.0",
                "node_id": "MDc6TGljZW5zZTk=",
                "spdx_id": "GPL-3.0",
                "url": "https://api.github.com/licenses/gpl-3.0"
            },
            "merges_url": "https://api.github.com/repos/sudden6/c-toxcore/merges",
            "milestones_url": "https://api.github.com/repos/sudden6/c-toxcore/milestones{/number}",
            "mirror_url": null,
            "name": "c-toxcore",
            "node_id": "MDEwOlJlcG9zaXRvcnk3MDA5MzcyOQ==",
            "notifications_url": "https://api.github.com/repos/sudden6/c-toxcore/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
                "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
                "followers_url": "https://api.github.com/users/sudden6/followers",
                "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
                "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sudden6",
                "id": 5585762,
                "login": "sudden6",
                "node_id": "MDQ6VXNlcjU1ODU3NjI=",
                "organizations_url": "https://api.github.com/users/sudden6/orgs",
                "received_events_url": "https://api.github.com/users/sudden6/received_events",
                "repos_url": "https://api.github.com/users/sudden6/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sudden6"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/sudden6/c-toxcore/pulls{/number}",
            "pushed_at": "2023-01-03T23:21:37Z",
            "releases_url": "https://api.github.com/repos/sudden6/c-toxcore/releases{/id}",
            "size": 16967,
            "ssh_url": "git@github.com:sudden6/c-toxcore.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/sudden6/c-toxcore/stargazers",
            "statuses_url": "https://api.github.com/repos/sudden6/c-toxcore/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/sudden6/c-toxcore/subscribers",
            "subscription_url": "https://api.github.com/repos/sudden6/c-toxcore/subscription",
            "svn_url": "https://github.com/sudden6/c-toxcore",
            "tags_url": "https://api.github.com/repos/sudden6/c-toxcore/tags",
            "teams_url": "https://api.github.com/repos/sudden6/c-toxcore/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/sudden6/c-toxcore/git/trees{/sha}",
            "updated_at": "2022-12-08T11:18:28Z",
            "url": "https://api.github.com/repos/sudden6/c-toxcore",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "ebbe631c714fe38c851495532fdc3fbb481da7f8",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
            "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
            "followers_url": "https://api.github.com/users/sudden6/followers",
            "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
            "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/sudden6",
            "id": 5585762,
            "login": "sudden6",
            "node_id": "MDQ6VXNlcjU1ODU3NjI=",
            "organizations_url": "https://api.github.com/users/sudden6/orgs",
            "received_events_url": "https://api.github.com/users/sudden6/received_events",
            "repos_url": "https://api.github.com/users/sudden6/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/sudden6"
        }
    },
    "html_url": "https://github.com/TokTok/c-toxcore/pull/1847",
    "id": 814169428,
    "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1847",
    "labels": [
        {
            "color": "0e8a16",
            "default": false,
            "description": "Adding missing tests, refactoring tests; no production code change",
            "id": 2037183222,
            "name": "test",
            "node_id": "MDU6TGFiZWwyMDM3MTgzMjIy",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/labels/test"
        }
    ],
    "locked": false,
    "merge_commit_sha": "f454eab493217133dcf8a841784acb65ebafd21a",
    "merged_at": null,
    "milestone": {
        "closed_at": null,
        "closed_issues": 0,
        "created_at": "2022-04-18T18:26:57Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
            "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
            "followers_url": "https://api.github.com/users/iphydf/followers",
            "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
            "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/iphydf",
            "id": 10647936,
            "login": "iphydf",
            "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
            "organizations_url": "https://api.github.com/users/iphydf/orgs",
            "received_events_url": "https://api.github.com/users/iphydf/received_events",
            "repos_url": "https://api.github.com/users/iphydf/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/iphydf"
        },
        "description": "",
        "due_on": null,
        "html_url": "https://github.com/TokTok/c-toxcore/milestone/49",
        "id": 7888300,
        "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/49/labels",
        "node_id": "MI_kwDOA7zIGs4AeF2s",
        "number": 49,
        "open_issues": 47,
        "state": "open",
        "title": "v0.2.20",
        "updated_at": "2024-02-23T15:20:22Z",
        "url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/49"
    },
    "node_id": "PR_kwDOA7zIGs4whz1U",
    "number": 1847,
    "patch_url": "https://github.com/TokTok/c-toxcore/pull/1847.patch",
    "requested_reviewers": [],
    "requested_teams": [
        {
            "description": "People with admin access on all repos",
            "html_url": "https://github.com/orgs/TokTok/teams/admins",
            "id": 3794282,
            "members_url": "https://api.github.com/organizations/17427091/team/3794282/members{/member}",
            "name": "Admins",
            "node_id": "MDQ6VGVhbTM3OTQyODI=",
            "notification_setting": "notifications_enabled",
            "parent": {
                "description": "Review and contribute code.",
                "html_url": "https://github.com/orgs/TokTok/teams/contributors",
                "id": 2069614,
                "members_url": "https://api.github.com/organizations/17427091/team/2069614/members{/member}",
                "name": "Contributors",
                "node_id": "MDQ6VGVhbTIwNjk2MTQ=",
                "notification_setting": "notifications_enabled",
                "permission": "pull",
                "privacy": "closed",
                "repositories_url": "https://api.github.com/organizations/17427091/team/2069614/repos",
                "slug": "contributors",
                "url": "https://api.github.com/organizations/17427091/team/2069614"
            },
            "permission": "pull",
            "privacy": "closed",
            "repositories_url": "https://api.github.com/organizations/17427091/team/3794282/repos",
            "slug": "admins",
            "url": "https://api.github.com/organizations/17427091/team/3794282"
        }
    ],
    "review_comment_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/TokTok/c-toxcore/statuses/ebbe631c714fe38c851495532fdc3fbb481da7f8",
    "title": "test: add tests for the ToxAV multithreading modes",
    "updated_at": "2024-01-13T01:18:45Z",
    "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/1847",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/5585762?v=4",
        "events_url": "https://api.github.com/users/sudden6/events{/privacy}",
        "followers_url": "https://api.github.com/users/sudden6/followers",
        "following_url": "https://api.github.com/users/sudden6/following{/other_user}",
        "gists_url": "https://api.github.com/users/sudden6/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/sudden6",
        "id": 5585762,
        "login": "sudden6",
        "node_id": "MDQ6VXNlcjU1ODU3NjI=",
        "organizations_url": "https://api.github.com/users/sudden6/orgs",
        "received_events_url": "https://api.github.com/users/sudden6/received_events",
        "repos_url": "https://api.github.com/users/sudden6/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/sudden6/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/sudden6/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/sudden6"
    }
}