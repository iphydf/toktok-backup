{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "I think I found few problems in onion client implementation. But I'd like someone to confirm it:\r\n\r\n- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1586\r\n\r\nIt seems it should be `or` instead of `and`. Otherwise there is no much sense in the second condition - we can ping a node, don't get a response and stop pings since this one node was pinged recently.\r\n\r\n- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1711\r\n\r\nThe condition here should be `list_nodes[i].unsuccessful_pings == 0 || list_nodes[i].unsuccessful_pings == 1 && mono_time_is_timeout(onion_c->mono_time, list_nodes[i].last_pinged, ONION_NODE_TIMEOUT)`. The same with the next condition.\r\n\r\n- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1721\r\n\r\nIt should be for all nodes instead of just the current one, like in `do_friend`. Otherwise each node will be pinged at the rate `ONION_NODE_PING_INTERVAL + MAX_ONION_CLIENTS_ANNOUNCE*3` maximum since `do_announce` executes every 3 seconds.",
    "closed_at": "2019-03-25T09:08:02Z",
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "* Wednesday, 2019-03-20 at 14:10 -0700 - Evgeny Kurnevsky <notifications@github.com>:\n\n>- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1586\n>\n>It seems it should be `or` instead of `and`. Otherwise there is no much \n>sense in the second condition - we can ping a node, don't get \n>a response and stop pings since this one node was pinged recently.\n\nI believe \"and\" is intended. It prevents this ping balancing mechanism \nfrom producing excess pings, in particular when `interval` is small.\n\n>- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1711\n>\n>The condition here should be `list_nodes[i].unsuccessful_pings == 0 || list_nodes[i].unsuccessful_pings == 1 && mono_time_is_timeout(onion_c->mono_time, list_nodes[i].last_pinged, ONION_NODE_TIMEOUT)`. The same with the next condition.\n\nWhy?\n\n>- https://github.com/TokTok/c-toxcore/blob/d14989f6dffedc8bc402afc2a503f72f8546fde6/toxcore/onion_client.c#L1721\n>\n>It should be for all nodes instead of just the current one, like in \n>`do_friend`. Otherwise each node will be pinged at the rate \n>`ONION_NODE_PING_INTERVAL + MAX_ONION_CLIENTS_ANNOUNCE*3` maximum since \n>`do_announce` executes every 3 seconds.\n\nI'm not sure what you mean here. This mechanism ensures we at least send \none ping per ONION_NODE_PING_INTERVAL seconds. Note that last_announce \ngets set each time.\n",
            "created_at": "2019-03-23T09:40:16Z",
            "html_url": "https://github.com/TokTok/c-toxcore/issues/1312#issuecomment-475855510",
            "id": 475855510,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312",
            "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTg1NTUxMA==",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475855510/reactions"
            },
            "updated_at": "2019-03-23T09:40:16Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475855510",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/590069?v=4",
                "events_url": "https://api.github.com/users/zugz/events{/privacy}",
                "followers_url": "https://api.github.com/users/zugz/followers",
                "following_url": "https://api.github.com/users/zugz/following{/other_user}",
                "gists_url": "https://api.github.com/users/zugz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zugz",
                "id": 590069,
                "login": "zugz",
                "node_id": "MDQ6VXNlcjU5MDA2OQ==",
                "organizations_url": "https://api.github.com/users/zugz/orgs",
                "received_events_url": "https://api.github.com/users/zugz/received_events",
                "repos_url": "https://api.github.com/users/zugz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zugz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zugz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zugz"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I believe \"and\" is intended. It prevents this ping balancing mechanism from producing excess pings, in particular when `interval` is small.\r\n\r\nThis condition is used only for `ping_random`, i.e. to check if we should ping one random node now. It doesn't depend on current `interval`. Also comment says:\r\n```\r\n// ensure we get a response from some node roughly once per\r\n// (interval / MAX_ONION_CLIENTS)\r\n```\r\nBut imagine that we sent a ping and the node didn't respond. In this case we won't ping some node again because of the first condition. Which means we won't get a response for `interval / MAX_ONION_CLIENTS` and will wait for another `ONION_NODE_PING_INTERVAL`.\r\n\r\n> Why?\r\n\r\nThis condition should check if node is alive and 'stable'. But what if it didn't respond last time? In this case it becomes 'unstable', we send another ping request and consider it 'stable' again for another `ONION_NODE_TIMEOUT` second, even if it's dead.\r\n\r\n> I'm not sure what you mean here. This mechanism ensures we at least send one ping per ONION_NODE_PING_INTERVAL seconds. Note that last_announce gets set each time.\r\n\r\nRight, but this check executes every 3 seconds for each node independently. It means that regardless of how big interval is it will likely be pinged after some time. The worst probability is `1 - (1 - 1/MAX_ONION_CLIENTS_ANNOUNCE)^n` (if we ignore `i`), which is ~0.9 for 90 seconds. So it means that each node will be pinged every 90 seconds with high probability regardless of interval. So instead of checking this condition for every node independently we should check it for all nodes, like we do in `do_friend`, setting `ping_random` variable. This way after one node was pinged we won't ping other nodes.",
            "created_at": "2019-03-23T10:11:59Z",
            "html_url": "https://github.com/TokTok/c-toxcore/issues/1312#issuecomment-475857436",
            "id": 475857436,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312",
            "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTg1NzQzNg==",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475857436/reactions"
            },
            "updated_at": "2019-03-23T10:18:32Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475857436",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2943605?v=4",
                "events_url": "https://api.github.com/users/kurnevsky/events{/privacy}",
                "followers_url": "https://api.github.com/users/kurnevsky/followers",
                "following_url": "https://api.github.com/users/kurnevsky/following{/other_user}",
                "gists_url": "https://api.github.com/users/kurnevsky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kurnevsky",
                "id": 2943605,
                "login": "kurnevsky",
                "node_id": "MDQ6VXNlcjI5NDM2MDU=",
                "organizations_url": "https://api.github.com/users/kurnevsky/orgs",
                "received_events_url": "https://api.github.com/users/kurnevsky/received_events",
                "repos_url": "https://api.github.com/users/kurnevsky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kurnevsky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kurnevsky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kurnevsky"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "* Saturday, 2019-03-23 at 03:11 -0700 - Evgeny Kurnevsky <notifications@github.com>:\n\n>> I believe \"and\" is intended. It prevents this ping balancing mechanism from producing excess pings, in particular when `interval` is small.\n>\n>This condition is used only for `ping_random`, i.e. to check if we should ping one random node now. It doesn't depend on current `interval`. Also comment says:\n>```\n>// ensure we get a response from some node roughly once per\n>// (interval / MAX_ONION_CLIENTS)\n>```\n>But imagine that we sent a ping and the node didn't respond. In this \n>case we won't ping some node again because of the first condition. \n>Which means we won't get a response for `interval / MAX_ONION_CLIENTS` \n>and will wait for another `ONION_NODE_PING_INTERVAL`.\n\nCorrect. Perhaps the comment is misleading (though the word \"roughly\" \ncould be understood as covering this).\n\nIf we do want to make many pings in quick succession in this \ncircumstance, it looks like we'd want a separate mechanism to do it. \nChanging the && to || isn't what we want - it would mean we ping at \nleast once per ONION_NODE_PING_INTERVAL, which may be a lot faster than \n`interval` asks for.\n\n>> Why?\n>\n>This condition should check if node is alive and 'stable'. But what if \n>it didn't respond last time? In this case it becomes 'unstable', we \n>send another ping request and consider it 'stable' again for another \n>`ONION_NODE_TIMEOUT` second which is not right, even if it's dead.\n\nYes, we give it another chance to prove its stability. Maybe \"stable\" \nisn't the best word here... but I'm not sure what's better, and the \ncurrent behaviour seems to make sense.\n\nConsidering a node as unstable if we've sent more than one unsuccessful \nping might make some sense with the way pings are currently sent, but it \ndoesn't make sense for the paths since we might well send multiple pings \nin quick succession on the same path. It seems good to keep the two \nparallel.\n\n>> I'm not sure what you mean here. This mechanism ensures we at least \n>> send one ping per ONION_NODE_PING_INTERVAL seconds. Note that \n>> last_announce gets set each time.\n>\n>Right, but this check executes every 3 seconds for each node \n>independently. It means that regardless of how big interval is it will \n>likely be pinged after some time. The worst probability is `1 - (1 \n>- 1/MAX_ONION_CLIENTS_ANNOUNCE)^n` (if we ignore `i`),\n\nDon't ignore i! The test is\n```random_u32() % (MAX_ONION_CLIENTS_ANNOUNCE - i) == 0```\nand since i ranges up to MAX_ONION_CLIENTS_ANNOUNCE-1\n(ignoring the exceptional case that some nodes are timed out, which is \nquickly dealt with),\nthis means that one node, chosen uniformly, does get pinged if \nlast_announce was at least ONION_PING_INTERVAL ago.\n\nSo if there were no other pinging, this would cause each node to be \npinged on average once per \nONION_PING_INTERVAL*MAX_ONION_CLIENTS_ANNOUNCE seconds, which as it \nhappens is exactly ANNOUNCE_INTERVAL_STABLE.\n\nOr am I missing something?\n\n\n>which is ~0.9 for 90 seconds. So it means that each node will be pinged \n>every 90 seconds with high probability regardless of interval. So \n>instead of checking this condition for every node independently we \n>should check it for all nodes, like we do in `do_friend`. This way \n>after one node was pinged we won't ping other nodes.\n",
            "created_at": "2019-03-23T15:44:25Z",
            "html_url": "https://github.com/TokTok/c-toxcore/issues/1312#issuecomment-475880004",
            "id": 475880004,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312",
            "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTg4MDAwNA==",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475880004/reactions"
            },
            "updated_at": "2019-03-23T15:44:25Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/475880004",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/590069?v=4",
                "events_url": "https://api.github.com/users/zugz/events{/privacy}",
                "followers_url": "https://api.github.com/users/zugz/followers",
                "following_url": "https://api.github.com/users/zugz/following{/other_user}",
                "gists_url": "https://api.github.com/users/zugz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zugz",
                "id": 590069,
                "login": "zugz",
                "node_id": "MDQ6VXNlcjU5MDA2OQ==",
                "organizations_url": "https://api.github.com/users/zugz/orgs",
                "received_events_url": "https://api.github.com/users/zugz/received_events",
                "repos_url": "https://api.github.com/users/zugz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zugz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zugz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zugz"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Correct. Perhaps the comment is misleading (though the word \"roughly\" could be understood as covering this). If we do want to make many pings in quick succession in this circumstance, it looks like we'd want a separate mechanism to do it. Changing the && to || isn't what we want - it would mean we ping at least once per ONION_NODE_PING_INTERVAL, which may be a lot faster than `interval` asks for.\r\n\r\nI thought it was supposed to provide reliable friends searching on big ping intervals when nodes/paths can become invalid. But ok, this makes sense because with no response we will try to ping nodes every `ONION_NODE_PING_INTERVAL`.\r\n\r\n> Yes, we give it another chance to prove its stability. Maybe \"stable\" isn't the best word here... but I'm not sure what's better, and the current behaviour seems to make sense.\r\n\r\nok then. Anyway it shouldn't be a big deal.\r\n\r\n> So if there were no other pinging, this would cause each node to be pinged on average once per ONION_PING_INTERVAL*MAX_ONION_CLIENTS_ANNOUNCE seconds, which as it happens is exactly ANNOUNCE_INTERVAL_STABLE.\r\n\r\nAh, I missed the fact that `last_announce` is global for all nodes. It's fine then.\r\n\r\nSo I guess the issue can be closed. Thanks!",
            "created_at": "2019-03-25T09:08:02Z",
            "html_url": "https://github.com/TokTok/c-toxcore/issues/1312#issuecomment-476110242",
            "id": 476110242,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312",
            "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NjExMDI0Mg==",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/476110242/reactions"
            },
            "updated_at": "2019-03-25T09:08:02Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/476110242",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2943605?v=4",
                "events_url": "https://api.github.com/users/kurnevsky/events{/privacy}",
                "followers_url": "https://api.github.com/users/kurnevsky/followers",
                "following_url": "https://api.github.com/users/kurnevsky/following{/other_user}",
                "gists_url": "https://api.github.com/users/kurnevsky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kurnevsky",
                "id": 2943605,
                "login": "kurnevsky",
                "node_id": "MDQ6VXNlcjI5NDM2MDU=",
                "organizations_url": "https://api.github.com/users/kurnevsky/orgs",
                "received_events_url": "https://api.github.com/users/kurnevsky/received_events",
                "repos_url": "https://api.github.com/users/kurnevsky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kurnevsky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kurnevsky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kurnevsky"
            }
        }
    ],
    "comments": 4,
    "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312/comments",
    "created_at": "2019-03-20T21:10:04Z",
    "event_data": [
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2943605?v=4",
                "events_url": "https://api.github.com/users/kurnevsky/events{/privacy}",
                "followers_url": "https://api.github.com/users/kurnevsky/followers",
                "following_url": "https://api.github.com/users/kurnevsky/following{/other_user}",
                "gists_url": "https://api.github.com/users/kurnevsky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kurnevsky",
                "id": 2943605,
                "login": "kurnevsky",
                "node_id": "MDQ6VXNlcjI5NDM2MDU=",
                "organizations_url": "https://api.github.com/users/kurnevsky/orgs",
                "received_events_url": "https://api.github.com/users/kurnevsky/received_events",
                "repos_url": "https://api.github.com/users/kurnevsky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kurnevsky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kurnevsky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kurnevsky"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2019-03-25T09:08:02Z",
            "event": "closed",
            "id": 2225843014,
            "node_id": "MDExOkNsb3NlZEV2ZW50MjIyNTg0MzAxNA==",
            "performed_via_github_app": null,
            "state_reason": null,
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/events/2225843014"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8304462?v=4",
                "events_url": "https://api.github.com/users/robinlinden/events{/privacy}",
                "followers_url": "https://api.github.com/users/robinlinden/followers",
                "following_url": "https://api.github.com/users/robinlinden/following{/other_user}",
                "gists_url": "https://api.github.com/users/robinlinden/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/robinlinden",
                "id": 8304462,
                "login": "robinlinden",
                "node_id": "MDQ6VXNlcjgzMDQ0NjI=",
                "organizations_url": "https://api.github.com/users/robinlinden/orgs",
                "received_events_url": "https://api.github.com/users/robinlinden/received_events",
                "repos_url": "https://api.github.com/users/robinlinden/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/robinlinden/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/robinlinden/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/robinlinden"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2019-05-20T21:43:45Z",
            "event": "milestoned",
            "id": 2354390447,
            "milestone": {
                "title": "v0.2.10"
            },
            "node_id": "MDE1Ok1pbGVzdG9uZWRFdmVudDIzNTQzOTA0NDc=",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/events/2354390447"
        },
        {
            "actor": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf"
            },
            "commit_id": null,
            "commit_url": null,
            "created_at": "2022-02-04T10:53:26Z",
            "event": "labeled",
            "id": 6008697228,
            "label": {
                "color": "eeeeee",
                "name": "P3"
            },
            "node_id": "LE_lADOA7zIGs4ZPbL_zwAAAAFmJXGM",
            "performed_via_github_app": null,
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/events/6008697228"
        }
    ],
    "events_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312/events",
    "html_url": "https://github.com/TokTok/c-toxcore/issues/1312",
    "id": 423473919,
    "labels": [
        {
            "color": "eeeeee",
            "default": false,
            "description": "Low priority",
            "id": 406490432,
            "name": "P3",
            "node_id": "MDU6TGFiZWw0MDY0OTA0MzI=",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/labels/P3"
        }
    ],
    "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312/labels{/name}",
    "locked": false,
    "milestone": {
        "closed_at": "2019-06-25T17:10:46Z",
        "closed_issues": 16,
        "created_at": "2019-05-20T21:39:38Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/8304462?v=4",
            "events_url": "https://api.github.com/users/robinlinden/events{/privacy}",
            "followers_url": "https://api.github.com/users/robinlinden/followers",
            "following_url": "https://api.github.com/users/robinlinden/following{/other_user}",
            "gists_url": "https://api.github.com/users/robinlinden/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/robinlinden",
            "id": 8304462,
            "login": "robinlinden",
            "node_id": "MDQ6VXNlcjgzMDQ0NjI=",
            "organizations_url": "https://api.github.com/users/robinlinden/orgs",
            "received_events_url": "https://api.github.com/users/robinlinden/received_events",
            "repos_url": "https://api.github.com/users/robinlinden/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/robinlinden/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/robinlinden/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/robinlinden"
        },
        "description": "",
        "due_on": null,
        "html_url": "https://github.com/TokTok/c-toxcore/milestone/38",
        "id": 4332830,
        "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/38/labels",
        "node_id": "MDk6TWlsZXN0b25lNDMzMjgzMA==",
        "number": 38,
        "open_issues": 0,
        "state": "closed",
        "title": "v0.2.10",
        "updated_at": "2020-03-20T20:17:05Z",
        "url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/38"
    },
    "node_id": "MDU6SXNzdWU0MjM0NzM5MTk=",
    "number": 1312,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312/reactions"
    },
    "repository_url": "https://api.github.com/repos/TokTok/c-toxcore",
    "state": "closed",
    "state_reason": "completed",
    "timeline_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312/timeline",
    "title": "Onion client review",
    "updated_at": "2022-02-04T10:53:26Z",
    "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/1312",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/2943605?v=4",
        "events_url": "https://api.github.com/users/kurnevsky/events{/privacy}",
        "followers_url": "https://api.github.com/users/kurnevsky/followers",
        "following_url": "https://api.github.com/users/kurnevsky/following{/other_user}",
        "gists_url": "https://api.github.com/users/kurnevsky/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/kurnevsky",
        "id": 2943605,
        "login": "kurnevsky",
        "node_id": "MDQ6VXNlcjI5NDM2MDU=",
        "organizations_url": "https://api.github.com/users/kurnevsky/orgs",
        "received_events_url": "https://api.github.com/users/kurnevsky/received_events",
        "repos_url": "https://api.github.com/users/kurnevsky/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/kurnevsky/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/kurnevsky/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/kurnevsky"
    }
}